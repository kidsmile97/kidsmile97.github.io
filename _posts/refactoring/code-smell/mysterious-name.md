---
---

# 神秘命名（Mysterious Name）

```
Tall is cheap, show me the code.
```

最好的注释永远是代码本身，而命名则是代码的开始。本文核心内容是介绍一些常见的命名手段，尽量避免最容易也最麻烦`神秘命名`这个代码坏味道。

### 命名是困难的

无论是变量、函数、类、包、程序...都需要一个命名，我们总希望它是简洁的、见名知意的，但有经验的猴子都知道，这是一件麻烦到令人作呕的事。

所以开发是总是受限于时间、对全局的把握程度、开发经验等等这些外在因素，命名只能在差不多就好了的范围。

一些受众广、优秀的开源代码，为了讨论其中 API 的命名，甚至会邀请众多开源贡献者，在社区专门开启较长时效的研讨会议、讨论区。

`命名是困难的，重命名更是`，所以请一开始就尽量给内容以合适的命名。

### 如何确定一个合适的命名-关于命名思考的方向

##### 1、它的内容（它代表了什么）

从它代表的内容来命名，通常在定义一个`实体`的时候，会根据它代表的内容来进行命名，它往往是一个`名词`性的词语。比如：

```JavaScript
// 定义一个数组访问下标，它代表的就是一个下标
let index = 0;
```

```Java
// 定义一个代表动物的类
class Animal {}
```

```Java
// 定义一个工具包，我们通常会把它命名为 util ，Date 表示它是一个代表时间的工具类
import java.util.Date;
```

```JavaScript
// 定义一个状态控制的标识
let loading = false;
```

##### 2、它的用途（用它来干什么）

从它的用途来命名，通常在定义一个`函数`的时候会从它的作用来进行命名，它往往是一个`动词`性的词语。比如：

```JavaScript
// 常见的数组 push 方法
const arr = new Array();
arr.push(1);
// 字符串切割方法
String('123_45').split('_');
```

##### 3、它的能力（它作用后的结果是什么）

从它的能力来命名，通常在定义一个`函数`的时候会从它的作用来进行命名。这里与通过用途的命名区别是`显式表明了它的用途与结果`，它往往是一个`动词-名词`组合性的词语。比如：

```Java
// 常见的 get/set 方法
class Person {
  private String name;
  setName(){};
  getName(){};
}
```

```rust
// rust 著名的类型转换函数命名规则
"string".as_bytes();
```

### 重构从改名开始

改名作为一种看上去简单的重构手段，实则蕴含着巨大的意义。随着程序不断地迭代壮大，部分代码随着使用范围增加需要提升作用域，改变代码位置结构，用于更大范围的作用域标识等等，旧的命名往往无法再涵盖表示其意义，重命名便是增加可读性的最简单有效的手段。

### 改名带来的麻烦

重命名是简单有效的，但却是麻烦、困难的。因为随着代码块的作用域范围、使用范围，改名必然导致牵一发而动全身的后果。作用域越小改名越方便，重构带来的提升必然也越小。

所以，实际上相较于收益，重命名的重构往往是被忽视的。

##### 重命名导致的版本前后不兼容问题

api 的命名是个典型的例子。一个优秀的开源依赖，改名导致的后果往往是崩溃式的，一般非大版本升级不改名。

目前常见的手段往往是改名后，仍保留原命名作为兼容的遗留内容，随着版本迭代、或者公告确定的抛弃版本、时间，完成整个重构的过程，而这个过程，往往是跨起码 2 个以上大版本的。

##### JavaScript 重命名的大麻烦

JavaScript 脚本语言以其非严格、动态性闻名并广泛至今，这种代码语言的重命名更为致命，哪怕现在已经有了诸如 typescript 强类型工具的限制，重命名仍是其面临的不小挑战。

由于动态性，作用域范围更自由，边编译边执行的特性，加上开发者的经验、水平等因素影响，重命名影响的范围甚至难以追溯，所以更显得其困难。
