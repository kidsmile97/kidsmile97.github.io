---
---

# 发散式变化（Divergent Change）

发散式变化讲的是某一个模块或者功能，会因为不同的原因做出的修改。核心表现：修改是`被不同的原因`触发的，违反了单一职责原则。

1. 不同的原因，即这个模块并不内聚，职责并不单一，所以会出现不同原因导致它本身发生变化。

2. 维护困难，不同原因维护后会增加代码混乱的可能性，增加出错的可能性。

### 什么时候你应该意识到出现这个问题

发散式变化其实是一个很容易出现的代码问题，因为迭代永远是紧凑的，但是经常性这个问题更多会被忽视：

> 因为每次迭代都间隔了一定的时间，每次都因为一个原因去修改它的时候，往往意识不大`发散`的存在。

> 意识到的时候，已经尾大不掉了，更少的开发时间完全无法覆盖重构的花费，`腐化`早有伏笔，`坏味道`由此散发

##### `大`：发散式变化最容易具有的特征

一个类、模块、功能越来越臃肿、庞大，那么`发散式变化`就大概率已经出现了。`大`并不是绝对特征，但是当一个内容很大，它又不是一个演算复杂内容的算法，它大概率职责不单一。

### 从一个例子看发散式变化的出现

```vue
<template>
  <!-- 初始需求：表格 -->
  <!-- 第二次迭代：删除数据 -->
  <!-- 第三次迭代：新增、修改数据 -->
  <!-- 第四次迭代：根据表格数据渲染图 -->
</template>
<script>
/**
 * 初始需求
 * （1）渲染表格
 * （2）请求数据
 */

/**
 * 第二次迭代
 * （1）请求删除接口删除数据
 * （2）刷新表格
 */

/**
 * 第三次迭代
 * （1）增加一个表单
 * （2）请求接口新增数据
 * （3）交互表格，请求接口编辑数据
 * （4）刷新表格
 */

/**
 * 第四次迭代
 * （1）增加一个可视化数据图
 * （2）处理数据渲染图形
 * （3）数据变动时更新图
 */
</script>
```

这里面描述了 4 次迭代，假设每次迭代都会为这个 vue 文件增加 200 行代码，那么多次迭代下来已经超过了 800 行。

里面包含了很多的状态变量、数据变量、事件、不同的接口服务，而且每次迭代都会依赖前面的数据、状态等等。

> 这里典型的发散式变化就是：或换个查询的接口、或换个可视化图形、或增加权限控制一些增删改...任意一个功能的变动，都必须改动这个文件，甚至可能会牵涉到各个功能之间的一些状态变量

### 如何处理发散式变化的问题

1. 合理辨别上下文。对于面向对象编程来说，单一职责原则其实就是一个合理上下文的标准。

所谓上下文，是指一个函数、一个类实现一个功能，所需要的最小执行环境。抽离不同的上下文，即把相关的内容放一起，比如 vue 的组合式函数、react 的 hook

2. 拆分代码。包括提炼类、提炼函数、拆分阶段等等

> 上文例子的重构方案，把各自功能通过 useService 函数包裹引入，通过事件进行功能模块间交互

```vue
<template>
  <!-- 初始需求：表格 -->
  <!-- 第二次迭代：删除数据 -->
  <!-- 第三次迭代：新增、修改数据 -->
  <!-- 第四次迭代：根据表格数据渲染图 -->
</template>
<script>
/**
 * 初始需求
 * useTableService;
 */

/**
 * 第二次迭代
 * useDeleteService;
 * onDelete => updateTable;
 */

/**
 * 第三次迭代
 * useCreateService;
 * useUpdateService;
 * onCreate\onUpdate => updateTable;
 */

/**
 * 第四次迭代
 * useChartService();
 * watch(data) => udpateChart;
 */
</script>
```
