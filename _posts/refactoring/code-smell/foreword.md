---
---

# 前言：代码坏味道并不是真的“坏”

在理解代码坏味道之前，是希望所有人理解，所谓的代码坏味道，并非是一种规则约束，更不是死板的教条主义，它是一本从“反面”描述、分析、理解代码的说明书。

比如你会知道`发散式变化`和`霰弹式修改`是一对仇人，你这个第三者靠近任何一个，都会引得另一方的`敌视`，所以最好的做法是中立在两者之间，利用高超的技术和经验，努力保持微妙的平衡。

`重复代码`和`重复Switches`像是一对父子，只是`重复Switches`这个儿子更具特性，`教育`它的方式更具哲学与方法论魅力，所以被单独拎了出来.

总之：它们各自种种的特性，它们之间那种微妙的联系与相爱相杀，一切的一切都说明了一点，`代码坏味道并不是真的“坏”`，它可以指导代码避雷，但不是圣经，有些明知的哑雷踩了也无妨。

### 适当的保持平衡

一匹马拉车，车前进得不紧不慢，两匹马拉车，速度稍有增加...于是你掌握了秘诀，不断加马，最后车被拉得散架惨遭分尸。

### 当需要时请尽量偏心

或许经过一段时间的学习和锻炼，你已经熟读经书，一眼所至即可精准扫描匹配出各种`坏味道`，但请相信我，请不要在`没有需要`的时候改动它。

##### 为什么不改动它？

有时候越是明显的坏味道，越是应该怀疑：为何当初要设计成如此？带着这种强烈的怀疑，你就不会轻易下手

或许不同人不同水平，所处的团队、环境也有高低，但在审视代码思考之时应抱有平庸的态度，把代码作者认为与自身水平无二致，无需高看，更不应该小觑，因为：

```
一般的工程师写高深代码，优秀的工程师写弱智代码。
```

这也是程序开发时应有的态度：接手代码的后来者一定是个弱智，而老前辈写的代码必然有其深意。

##### 什么时候需要改动它？

懂得都懂，当你需要改动某个地方实现需求之前，就是最好的重构时机（前提是有较为充分的时间）

因为改动某个地方，必然需要对其上下文、实现功能、运行逻辑都有所了解，这样相当于你抓住了该段代码的前世今生，此时你还觉得这里的`坏味道`臭不可闻

> Just Do It!

##### 更好的改动时机在你做好了必要的准备

最好的识别重构代码时机是在你需要改动它之前，但更好的时机是，你决心要改动这段代码。

1. 梳理代码上下文、依赖、引用链

2. 明晰代码逻辑、功能

3. 识别坏味道，设计重构方案，最后：请留下你浓墨重彩的一笔！

### 没有完美的代码，正如没有完美

如果你熟知各种工程设计，那你就会知道，通常在了解完一个模式的优雅、巧妙之处时，你就该看到它的不足。

> 每个当下看似完美的设计，都将在未来的某一天，成为制约代码持续演进的铜墙铁壁。

所以重构的核心并不是消灭所有的`坏味道`，而是`消灭影响代码当前演进道路的坏味道`，引入的新问题无关要紧。

即除了程序本身，坏味道也是在动态的演进的，哪来的完美代码呢？

by the way: AI maybe the only perfect one, when it could design programming by itself.

### 最后送给各位一句本人心目中的圣经

```
Stay Hungry, Stay Foolish.
```
